description "Starphleet order needs to be served"

setuid admiral
stop on stopping starphleet

instance $local

respawn

pre-start script
  date
  source /var/starphleet/.headquarters
  #make sure we have the needed docker container images built to serve
  #the image will be tagged with the SHA of the repository but don't
  #get them confused with the SHA that Docker makes for the resulting image
  get_CURRENT_SHA "${local}"
  #build the image starting from our clone
  cd "${local}"
  pwd
  docker images | grep ${CURRENT_SHA} > .exist || true
  if [ -s .exist ]; then
    echo image is already available
  else
    docker build -t ${CURRENT_SHA} "${local}"
    #docker build exits 0 even when it fails. bummer
    docker images | grep ${CURRENT_SHA} > .exist || true
    if [ -s .exist ]; then
      echo image built
    else
      echo image failed
      exit 1
    fi
  fi
end script

script
  echo starting container
  source /var/starphleet/.headquarters
  #run at the current SHA
  get_CURRENT_SHA "${local}"
  #the monitoring triggered in the git repository, so we need to go up a level
  #to write out the cid file
  cd "${local}/.."
  ORDER=$(pwd)
  #run the docker container as a service process, not as a daemon
  SERVICE="${CURRENT_SHA}"
  #count on upstart to be the daemon manager, not docker
  docker run -cidfile="${ORDER}/${SERVICE}.cid" -t -v /var/starphleet:/var/starphleet:ro "${CURRENT_SHA}"
end script

post-start script
  source /var/starphleet/.headquarters
  get_CURRENT_SHA "${local}"
  cd "${local}/.."
  ORDER=$(pwd)
  SERVICE="${CURRENT_SHA}"
  #wait for the CID to appear, means docker did its bit for starphleet
  #YOU SHOULD DO YOUR BIT FOR STARPHLEET TOO!
  while [ ! -f "${ORDER}/${SERVICE}.cid" ]
  do
    sleep 1
  done
  CID=$(cat "${ORDER}/${SERVICE}.cid")
  #slash-less, makes a nice file name
  PACKED_ORDER=$(echo ${ORDER} | sed -e "s[/[_[g")
  #ask docker for a bunch of nice info about the container now that it is started
  #including the super interesting EXPOSE ports
  docker inspect ${CID} > "${ORDER}/container.json"
  #this uses our code generator to mix the private ports from the container with
  #the EXPOSE dynamic ports from the order's Dockerfile to create a mapping of
  #the actual ports that happened to be used, which we'll leverage in nginx
  generate info "${ORDER}/order" "${ORDER}/container.json" > "${ORDER}/info.json"
  # we'll check each mapped port for an available http service
  for port in `phleet generate containerPorts "${ORDER}/info.json"`
  do
    # the port can come in with some awesome whitespace which is a disaster,
    # so we remove it
    port=`echo ${port} | sed -e "s/[[:space:]]//g"`
    # this will wait until we get a 200 from the url and exit 0, if it never
    # comes back it will return a 1 which upstart hates, so we'll ignor it
    # we also may want to add a configurable diagnostic endpoint, but that seems 
    # excessive for now
    http_ready "http://localhost:${port}/diagnostic" || true
    # as you can tell from '|| true' this will come back even if things don't go
    # as expected.  There's only so much we can do, in this case we will have
    # not received a 200 in 10 seconds so we'll continue on hoping for the best. 
    # This, of course, will also allow services that don't return a 200 on 
    # diagnostic to come up after the 10 second check period
  done
  #hard link, keeps track of running containers
  ln "${ORDER}/info.json" "${CURRENT_CONTAINERS}/${PACKED_ORDER}.json"
end script

post-stop script
  set +e
  source /var/starphleet/.headquarters
  echo container stopped, cleaning up
  get_CURRENT_SHA "${local}"
  cd "${local}/.."
  ORDER=$(pwd)
  SERVICE="${CURRENT_SHA}"
  CID=$(cat "${ORDER}/${SERVICE}.cid")
  PACKED_ORDER=$(echo ${ORDER} | sed -e "s[/[_[g")
  #this just removes all the files we created in post-start, so if you add a file
  #there, add it here. FOR STARPHLEET!
  rm "${ORDER}/${SERVICE}.cid"
  rm "${ORDER}/container.json"
  rm "${ORDER}/info.json"
  rm "${CURRENT_CONTAINERS}/${PACKED_ORDER}.json"
end script
