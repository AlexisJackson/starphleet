description "Starphleet order needs to be served, which is running a container for a given image version"

stop on stopping starphleet

#name is to let us have multiple running versions of the same order
instance $name
#also expects $image and $order

respawn

pre-start script
  source /var/starphleet/.headquarters
  #build the container, this is based not on the repository but on
  #the build script within
  starphleet-build "${order}/git" "${order}/container"
  CONTAINER_NAME=$(cat "${order}/container")
  INSTANCE_NAME="${CONTAINER_NAME}-$$"
  CONTAINER_ROOT=/var/lib/lxc/${INSTANCE_NAME}/rootfs
  #make a container, this sets up a file system
  lxc-clone -o "${CONTAINER_NAME}" -n "${INSTANCE_NAME}" -s
  #block script, makes sure we are on the air
  cat $(which starphleet-wait-network) > "${CONTAINER_ROOT}/.block"
  chmod +x "${CONTAINER_ROOT}/.block"
  #create the 'run' script, this does the actual doing
  EXTRACTOR='
    /run script/ { in_it = 1; next;}
    /end script/ {in_it = 0;}
    {if (in_it) print $0;}
  '
  RUNNER="${CONTAINER_ROOT}/.run"
cat << EOF > ${RUNNER}
#need to be in the directory for the source
  cd local_repository
EOF
  cat "${order}/git/Starphleet" | awk "${EXTRACTOR}" - >> ${RUNNER}
  #always able to see your own source
  if btrfs subvolume snapshot "${order}/git" ${CONTAINER_ROOT}; then
    echo Used a snapshot
  else
    echo Used a copy
    cp -R "${order}/git" "${CONTAINER_ROOT}/local_repository"
  fi
  #get running and make sure the network is up
  lxc-start --name ${INSTANCE_NAME} -d
  lxc-wait --name ${INSTANCE_NAME} --state RUNNING
  lxc-attach --name ${INSTANCE_NAME} -- /.block
  echo "${INSTANCE_NAME}" > "${order}/${name}.instance"
  IP_ADDRESS=$(lxc-ls --fancy | grep "${INSTANCE_NAME}" | awk '{ print $3; }')
  echo "${IP_ADDRESS}" > "${order}/${name}.ip"
end script

script
  echo 'running'
  source /var/starphleet/.headquarters
  INSTANCE_NAME=$(cat "${order}/${name}.instance")
  #at this point, the container is running and can be really used
  lxc-attach --name ${INSTANCE_NAME} -- bash /.run
end script

post-start script
  echo 'started'
  source /var/starphleet/.headquarters
  CONTAINER_IP=$(cat "${order}/${name}.ip")
  echo $CONTAINER_IP
  cat "${order}/order"
  exit 0
  #this uses our code generator to mix the private ports from the container with
  #the EXPOSE dynamic ports from the order's Dockerfile to create a mapping of
  #the actual ports that happened to be used, which we'll leverage in nginx
  generate info "${name}" "${order}/order" "${order}/container.json" > "${order}/info.json"
  # we'll check each mapped port for an available http service
  for port in `generate containerPorts "${order}/info.json"`
  do
    # the port can come in with some awesome whitespace which is a disaster,
    # so we remove it
    port=`echo ${port} | sed -e "s/[[:space:]]//g"`
    # this will wait until we get a 200 from the url and exit 0, if it never
    # comes back it will return a 1 which upstart hates, so we'll ignor it
    # we also may want to add a configurable diagnostic endpoint, but that seems
    # excessive for now
    http_ready "http://localhost:${port}/diagnostic" || true
    # as you can tell from '|| true' this will come back even if things don't go
    # as expected.  There's only so much we can do, in this case we will have
    # not received a 200 in 10 seconds so we'll continue on hoping for the best.
    # This, of course, will also allow services that don't return a 200 on
    # diagnostic to come up after the 10 second check period
  done
  #at this point we have a running container, and it answers HTTP, so we
  #are on the air and can expose it via nginx
  #slash-less, makes a nice file name
  PACKED_ORDER=$(echo ${order} | sed -e "s[/[_[g")
  #hard link, keeps track of running containers
  ln "${order}/info.json" "${CURRENT_CONTAINERS}/${PACKED_ORDER}.json"
end script

post-stop script
  INSTANCE_NAME=$(cat "${order}/${name}.instance")
  lxc-stop --name ${INSTANCE_NAME}
  lxc-wait --name ${INSTANCE_NAME} --state STOPPED
  lxc-destroy --name ${INSTANCE_NAME}
  rm "${order}/${name}.ip"
  rm "${order}/${name}.instance"
end script
