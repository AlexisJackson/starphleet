description "Starphleet order needs to be served, which is running a container for a given image version"

stop on stopping starphleet

#name is to let us have multiple running versions of the same order
instance $name
#also needs
# - $order: the directory where the ordered repository is cloned

respawn

pre-start script
  source /var/starphleet/.headquarters
  CONTAINER_NAME="${name}"
  CONTAINER_ROOT=/var/lib/lxc/${CONTAINER_NAME}/rootfs
  ORDER_LOCAL="${CURRENT_ORDERS}/${order}/git"
  #flockin, LXC doesn't appear to like doing concurrent builds with BTRFS
  #so hey, we pop in a flock, and if all else fails, this script respanws a lot
  #notice how we are cloning from the *local*, no need for a network trip...
  echo 'building' > "${CURRENT_ORDERS}/${order}/.starphleetstatus"
  flock "${CURRENT_ORDERS}" -c "starphleet-containerize ${ORDER_LOCAL} ${CONTAINER_NAME}"
  # environment, enforced by our buildpack script, so the preference order is:
  # * repository specific variables, basically our dev settings
  # * headquarters/.../orders variables, service level overrides
  # * headquarters/.starphleet variables, global overrides
  if [ -f "${HEADQUARTERS_LOCAL}/.starphleet" ]; then
    cat "${HEADQUARTERS_LOCAL}/.starphleet" >> "${CONTAINER_ROOT}/.starphleet"
  fi
  #the orders file itself is a source of variables
  echo 'autodeploy () { export AUTODEPLOY="$1"; }' > "${CONTAINER_ROOT}/.orders"
  cat "${CURRENT_ORDERS}/${order}/orders" >> "${CONTAINER_ROOT}/.orders"
  #and finally, the buildpack web start
  echo '/start web' > "${CONTAINER_ROOT}/web"
  chmod +x "${CONTAINER_ROOT}/web"
  echo 'built' > "${CURRENT_ORDERS}/${order}/.starphleetstatus"
  info ready to serve web
end script

script
  source /var/starphleet/.headquarters
  CONTAINER_NAME="${name}"
  #at this point, the container is running and can be really used
  lxc-attach --name ${CONTAINER_NAME} -- /web
end script

post-start script
  set +e
  source /var/starphleet/.headquarters
  export CONTAINER_NAME="${name}"
  echo 'checking' > "${CURRENT_ORDERS}/${order}/.starphleetstatus"

  #sourcing here to get variables
  autodeploy () { echo -n; }
  export -f autodeploy
  test -f "${CURRENT_ORDERS}/${order}/orders" && source "${CURRENT_ORDERS}/${order}/orders"
  test -f "${HEADQUARTERS_LOCAL}/.starphleet" && source "${HEADQUARTERS_LOCAL}/.starphleet"

  available () {
    #at this point we have a running container, and it answers HTTP, so we
    #are on the air and can expose it via nginx
    PUBLICATION_NAME=$(echo ${order} | sed -e "s[$/[_[")
    test ! -d "${NGINX_CONF}/published" && mkdir -p "${NGINX_CONF}/published"
    PUBLISH_CONF="${NGINX_CONF}/published/${PUBLICATION_NAME}.conf"
    PUBLISH_DIR=$(dirname "${PUBLISH_CONF}")
    test ! -d "${PUBLISH_DIR}" && mkdir -p "${PUBLISH_DIR}"
    starphleet-publish "${CONTAINER_NAME}" $PORT "/${order}" > "${PUBLISH_CONF}"
    info service published to "/${order}"
    reload starphleet_nginx
    echo 'online' > "${CURRENT_ORDERS}/${order}/.starphleetstatus"
  }

  if [ -f "${CURRENT_ORDERS}/${order}/git/healthcheck" ]; then
    HEALTHCHECK=$(cat "${CURRENT_ORDERS}/${order}/git/healthcheck")
  else
    HEALTHCHECK='/'
  fi
  if starphleet-ready "${CONTAINER_NAME}" "${PORT}" "${HEALTHCHECK}"; then
    available
  else
    #at this point the service has failed to properly start
    warn service failed to publish "/${order}"
    echo 'failed' > "${CURRENT_ORDERS}/${order}/.starphleetstatus"
  fi
end script

post-stop script
  set +e
  source /var/starphleet/.headquarters
  export CONTAINER_NAME="${name}"
  lxc-stop --name ${CONTAINER_NAME}
  starphleet-wait-lxc ${CONTAINER_NAME} STOPPED
  lxc-destroy --name ${CONTAINER_NAME}
  echo 'offline' > "${CURRENT_ORDERS}/${order}/.starphleetstatus"
end script
